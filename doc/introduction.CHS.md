#  Dragonboat使用入门 #

本文档提供Dragonboat的使用入门信息，阅读完后您将可以自如的使用Dragonboat库在您的项目中实现您所需要的各类有强一致需求的功能与组件。本文档假设您已掌握Go编程，但您无需对Raft或其它任何分布式共识算法有任何掌握。作为入门类工程性文档，本文刻意避免过多理论化、原理型描述，对这方面有兴趣的用户请参考各类分布式算法相关论文。

## 分布式共识算法 ##

如果您对Raft等分布式共识算法已经有足够了解，可以跳过本节。

为了避免单点问题，我们希望数据有多个副本且被保存在多个服务器上，当某一台或几台服务器出现当机时，根据副本数和位置可以有机会使得数据依旧在线进而服务继续可用，这也就是大家常说的高可用。存储在多个服务器上的多个副本同时提供了更高的整体读带宽，这对互联网应用普遍具有的高读写比特性也具备实际意义。

以三个副本的数据为例，如果不考虑三个副本是否一致，只要任何一个副本在线，我们就可以认为数据可用。但这样的做法引入了副本间数据不一致的问题，把麻烦推给了应用，目前这种做法已经逐渐基本淘汰。在多数副本在线这一前提下，即三个副本中的至少两个可用时，共识算法可以使得这三个副本在外界看起来始终一致并可用。目前，所有主要互联网公司均开始不同程度使用共识算法来达到上述高可用与副本数据一致。

为了提供这样的数据一致与高可用，同时保证应用开发的方便，共识算法提供了一种称为复制状态机的系统模型。用户的应用被抽象为状态机，对状态机状态的更新由用户提交的称为Proposal的提议来实现。共识算法确保当有多个用户提交不同提议时，那些被多数副本成功收到且持久保存的提议会被采纳（committed），在不同的副本上，各提议将被赋予相同的index序号并根据该序号顺序记录在称为Log的一个有序数据结构中。这些被采纳的提议，又会以上述既定的顺序被逐一应用到用户应用的状态机中以更新状态机的状态。当状态机的多个副本的初始状态相同，且在各个副本上均严格按照Log内的内容逐一更新，那么Log中同一被采纳的提议被执行后，各个状态副本的状态也将是相同的。

增加例子

读操作的一致性需要满足以下两点：
* 当一个写请求以提议的形式被采纳以后，此时通过读操作，必须可以读到这个写请求的结果，或者比它更新的结果。
* 当一个读请求返回了结果后开始下一个新的读请求，该新的读请求必须返回上一次读的结果或比它更新的结果。

共识库最主要功能即实现共识算法并提供编程接口供使用者实现他们的应用状态机，进而方便用户使用共识库的状态机读写功能来操作应用状态机，方便其实现其各项业务逻辑。

下面各节将展开讨论如何使用dragonboat提供的各项便利，方便的构建基于Raft分布式共识算法的应用。

## 术语 ##

Raft组：Raft协议控制下的一个独立的具有多个副本的实体，组内各个副本提供上一节中描述的一致性保证。一个应用可以使用管理一个或者多个Raft组。每个Raft组由一个系统内全局唯一的用户设定的64位整形数ClusterID来指代。
集群Cluster：Raft组的别称。
节点Node：Raft组中的一个成员副本。每个节点由一个Raft组内唯一的用户设定的64位整形数NodeID来指代。
Leader：Raft协议中定义的扮演Leader角色的节点。每个Raft组应有一个Leader节点，只有当Leader节点确定时才能对该Raft组进行读写。
快照Snapshot：把状态机在某具体时间点上的状态完全保存所得到的数据，可用于快速恢复状态机状态。

## 状态机 ##

状态机是用户应用的核心，它实现用户的业务逻辑，比如当您想构建类似Redis的基于内存的Key-Value数据库，那您的状态机就是这样一个KV数据库。状态机同时也是用户应用与Dragonboat一大交互接口，Dragonboat库通过状态机所实现的IStateMachine或IOnDiskStateMachine接口与之交互，完成状态机状态更新与查询等操作。

### 普通状态机 ###

普通状态机通常将数据存放于内存内，这决定了其总的数据量相对较小。普通状态机的状态会在每次节点重启后被完全重置，其存储于磁盘上的数据也需要清理并忽略，需要Dragonboat通过已持久化保存的Log或者快照Snapshot给予恢复。它的特点是实现简单、吞吐可达千万次每秒，但定期的保存快照Snapshot以及每次重启后重建状态所带来额外的IO开销较大。较常见的此类状态机的例子是类似Redis的基于内存的Key-Value数据库。此类型状态机是Raft论文中提及的通常类型的状态机。

用户需要实现statemachine包中的IStateMachine接口以实现这类普通状态机。此类状态机状态在每次重启后应确保其初始状态为空，Dragonboat负责通过状态机的Update与RecoverFromSnapshot两个方法来恢复状态机的状态。请注意，普通状态机的状态在重启后被重置，但没有任何数据会被丢失，系统会使用持久保存的快照Snapshot和Log来重建状态机状态。

### 基于磁盘的状态机 ###

基于磁盘的状态的主要数据保存于磁盘上，因此其总数据量相对较大，状态机的状态始终在磁盘上持久保存，每次节点重启后状态机状态不受影响。Dragonboat依旧需要定期保存快照Snapshot，但此类快照仅包含少量元数据，创建的开销及小。它的特点是实现较前述普通状态机稍复杂一些，吞吐受落盘影响较小，但它定期保存快照的额外IO开销极小。此类型状态机是Raft论文5.2节提及的特殊类型状态机。

用户需要实现statemachine包中的IOnDiskStateMachine接口以实现基于磁盘的状态机。此类基于磁盘的状态机由用户负责其状态的持久化保存，Dragonboat仅负责在每次重启后打开并启用已保存的状态机。

### 两类状态机的选择 ###

上述两类状态机的选择的最重要指标是状态机所管理的总数据大小。在所有状态机数据可以被存放于内存内的时候，比如几十G字节以内，建议使用基于内存的状态机，基于磁盘的状态机可以视为是状态机管理数据量较大情况下的一种针对避免额外IO开销的优化。

## 写操作 ##

对状态机的写操作称为提议Propose。用户可以通过使用NodeHost的Propose与SyncPropose方法发起异步或者同步的提议。

前述的共识算法常识可知，一个Raft组的过半数成员在线且可以互相正常交换网络消息，此时用户的提议才可以称为采纳状态最终被送至各状态机的副本执行。Dragonboat通过向状态机接口的Update方法提供已采纳的提议，供状态机依次执行。

NodeHost的Propose方法开始一个异步的提议，它会立刻返回，如果发起成功它会提供一个RequestState对象，用户可以通过它等待提议的操作结果并获取结果状态。一个被成功开始提出的提议的可能结果有成功、超时和失败。成功表示提议被采纳且已经被应用当当前的节点Node中，此后所有开始的读操作均将可以读到该提议的执行结果或者更新的结果。超时表示在制定的时间内无法完成提议的整个流程，提议状态未明，这是典型的分布式系统中的三态情况。失败是指想Propose提供的参数不合理或节点在提议流程完成前已经被关闭。

NodeHost的SyncPropose方法开始一个同步的提议，调用者的Goroutine会被挂起直到SyncPropose返回了明确成功、超时或者错误结果才会返回。它目前是对Propose方法的一个封装，可查看源代码比较两者实现的区别。

因为写操作超时以后导致上述三态情况，当用户重试一个超时的写请求的时候需要充分考虑这一情况，确保之前超时的操作如果已经成功执行了写操作，那么再次重试的时候的写操作不会对系统带来负面干扰，这样的特性称为幂等。显然，用户可以选择在状态机的设计上实现自己的幂等处理的方法。用户同时也可以选择使用Dragonboat自带的针对普通状态机的幂等方案，该方案基于Raft论文。

简单来说，Propose与SyncPropose方法均需要一个称为Session的输入参数，它是一个客户端访问状态进行写的Session。当用户选择不使用Dragonboat内建的幂等功能的时候，可以使用通过调用NodeHost的GetNoOPSession方法获得一个NOOP Session，它仅用来指明写操作针对的Raft组的ClusterID标示。如果选择使用内建的幂等支持，那可以使用GetNewSession以获取一个有效的具体Session对象，并在当前的client每次调用Propose或者SyncPropose方法时使用这个Session对象。当Propose或SyncPropose成功后，需要调用Session的ProposalCompleted方法，而Propose或SyncPropose超时后则不调用ProposalCompleted方法而直接再次调用Propose或SyncPropose来重试已超时的提议。

基于磁盘的状态机不支持该内置的幂等功能，如有需求，用户需自行实现幂等。

写操作的用户输入数据应该是状态机执行更新操作的唯一输入数据来源，状态机在Update方法被调用以更新状态机状态时，不应该使用诸如系统时间、随机数、当前进程号等等在各个副本上不确定的数据源。

## 读操作 ##

对状态机的读操作通常用以查询状态机内容与状态，且读操作不改变状态机的状态。读操作必须采用确保一致性的协议，绝不可直接读取状态机内容。Dragonboat使用Raft论文中描述的称为ReadIndex的协议，来实现高效的确保一致性的读。用户可以使用NodeHost的SyncRead以及ReadIndex与ReadLocal的组合方式，完成对状态机的读。

与写操作类似，读操作所依赖的ReadIndex协议的顺利执行需要一个Raft组的过半数成员在线且可以互相正常交换网络消息。Dragonboat通过向状态机接口的Lookup方法提供用户查询内容，执行后向用户返回查询结果。

NodeHost的ReadIndex方法开始一次异步的ReadIndex协议的执行，它立刻返回一个RequestState对象，用户可以通过它等待ReadIndex协议执行的成功。一旦成功，用户可以马上使用ReadLocal方法对同一节点开始查询操作。与前述的Propose方法类似，一个被成功开始的ReadIndex协议可能有三种结果，分别为成功、超时和失败。超时和失败的意义与Propose的超时或失败类似。ReadLocal方法只有在每次ReadIndex成功后才可以被调用，直接调用ReadLocal将直接破坏所读取得到的结果的一致性保证。

NodeHost的SyncRead方法进行一次同步的读操作，该方法只有当SyncRead返回了明确的查询结果或者确认了超时或者失败以后才会返回。它是对ReadIndex与ReadLocal方法的一个封装，可查看源代码参考具体实现的方法。

因为读操作始终不改变状态机状态，因此读操作超时以后不存在写操作超时以后的三态问题，也因此不设计幂等操作的考虑。

## 成员变更 ##

对于一个Raft组，成员变更可以改变其成员节点Node的组成，比如可以增加一个新节点或者删除一个已经失效的节点。成员变更对于用户状态机透明，无需用户在状态机内做任何处理，用户只需要通过NodeHost的RequestAddNode与RequestRemoveNode方法来增删节点完成成员变更。

成员变更的注意事项如下：
* 成员变更的操作本身也是通过Raft协议的一种提议，与普通的用户提议一样，被采纳的成员变更操作会被持久保存并复制到各副本节点。
* 已经被删除的节点不允许被再次添加回Raft组内。
* 成员变更改变系统对于Raft组成员信息的记录，所增删的节点需由用户负责实际启停。
* 对于每个Raft组，成员变更需要逐个依次进行，一次只能有一个等待完成的成员变更请求。

## 快照Snapshot ##

快照是对某一特定时间点时候节点状态的一次保存，快照含有如下信息：
* 当前已执行的提议的序号
* 当前Raft组成员信息
* 当前活动的用户Session信息
* 用户状态机当前状态

快照Snapshot有如下作用：
* 普通状态机重启后状态被重置，使用快照可以快速恢复状态机状态，无需使得状态机逐一执行大量的历史Log以恢复状态机状态，通常可节省执行时间与磁盘读带宽消耗。
* Raft组中某节点显著落后于Leader节点时，Leader可以通过向该落后节点网络发送快照而非逐一复制各提议，通常可节省传输时间与带宽。
* 普通状态机状态被保存至快照后，该节点之前的历史Log均可清理以释放磁盘存储空间。

状态机接口的SaveSnapshot方法用于将状态机状态保存至一个io.Writer对象中，RecoverFromSnapshot方法负责将以io.Reader形式提供的快照数据恢复至状态机内完成快照的应用。快照内其余信息，如当前成员与Session信息，均由Dragonboat负责维护。

由前述关于状态机一致性的描述可知，当状态机执行至某特定提议，那么所有副本的状态应该是相同。对于快照，我们要求快照的产生也考虑这点，状态机执行至某特定提议后开始产生快照，此时状态机多个副本所产生的快照应该是严格相同的。

用户可以通过启动各个节点时提供的Config实例中的SnapshotEntries字段设置每执行多少个提议进行一次快照的保存，通常：
* 对于普通状态机，建议一天保存1-2次快照
* 对于基于磁盘的状态机，建议XXXXXXXXX

## 其它功能 ##

Dragonboat通过NodeHost提供下列其它常用功能：

观察者Observer节点。观察者节点不参与Leader的选举，不参与一个提议是否可以被采纳，它仅仅用来接受并执行Raft组各个已采纳的提议。观察者这点的状态机与普通节点一样，正常情况下将具备完整且相同的状态机状态，它可以被用来供用户读取有一致性保证的状态机状态。观察者节点的另一大作用是允许一个新加入的节点以观察者身份加入Raft组，在其逐渐获取所有状态机状态后再提升其为正常节点。

Leader迁移。正常情况下，Leader以选举方式由用户程序透明的方式选举产生。用户可以使用NodeHost提供的RequestLeaderTransfer方法尝试将Leader迁移至指定节点。

NodeHost同时提供GetNodeHostInfo与GetClusterMembership方法供查询当前各NodeHost管理下的Raft组的信息。
